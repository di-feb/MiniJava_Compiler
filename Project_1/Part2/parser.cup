import java_cup.runtime.*;

//  Usercode Components
parser code {:
    // Connect this parser to a scanner!
    Lexer s;
    Parser(Lexer s){ this.s=s; }
:}

// Define how to connect to the lexer!
scan with {: return s.next_token(); :};


// Symbol Lists
// Terminals (tokens returned by the scanner).
// Lexical Analysis is the process of converting a stream
// of characters into a sequence of tokens.
// A token represents a string with an assigned meaning
// that describes a series of related lexemes.
// A lexeme is a contiguous sequence of characters
// that form a lexical unit in the grammar of a language.

terminal            PLUS, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, IF, ELSE, PREFIX, REVERSE;
terminal String     STRING_LITERAL, IDENTIFIER;        

// Non terminals
non terminal        program, definition_list, definition, call_list, parameters_list, parameters, block, expr, if_else, call, condition, nested ;

// Precedence Declarations
// In contrast to JFlex, precedence in CUP works bottom to up.
// That is, the earlier the declaration, the lower the precedence.
precedence left PLUS;
precedence left PREFIX;
precedence left REVERSE;


// // The Grammar Rules
start with program;
// The programms are concluded from function definitions and calls. 
// At the output we see the calls first and then the definitions.
program ::= definition_list:def_ls call_list:cls {: System.out.println("public class Main{\n\tpublic static void main(String[] args){\n" + cls + "\t}\n" + def_ls + "\n}"); :}
;
// definition_list
definition_list ::= definition_list:def_ls definition:def   {: RESULT = def_ls + "\n" + def; :}
                |                                           {: RESULT = ""; :}                                       
;
// definition
definition ::= call:c LBRACKET block:bl RBRACKET  {: RESULT = ("\tpublic static String " + c + "{\n\t\t" + bl + "\n\t}"); :}
;

call_list ::= call:c call_list:cl   {: RESULT = "\t\tSystem.out.println(" + c + ");\n" + cl; :} 
            |                       {: RESULT = ""; :}  
;

call ::= IDENTIFIER:id LPAREN parameters_list:p RPAREN  {: RESULT = id + "(" + ((String)p).replaceAll("String ","") + ")"; :}
;
// parameters_list
// parameters are comma separated identifiers.
parameters_list ::= parameters_list:p_list parameters:p {: RESULT = ((String)p_list + (String)p); :}
                |                                       {: RESULT = ""; :}  
;   
// parameters
parameters ::= IDENTIFIER:id COMMA      {: RESULT = "String " + id + ", "; :}
            | IDENTIFIER:id             {: RESULT = "String " + id; :}
            | STRING_LITERAL:str COMMA  {: RESULT = "String " + "\"" + str + "\"" + ", "; :}
            | STRING_LITERAL:str        {: RESULT = "String " + "\"" + str + "\""; :}
            | call:c                    {: RESULT = c; :}
            | call:c COMMA              {: RESULT = c + ", "; :}
;

// Code block could be:
// just a string
// the arguments concatenated with + 
// call of a function
// a series of if statements.
block ::= expr:ex            {: RESULT = "return " + ex + ";"; :}
        | nested:n           {: RESULT = "return " + n + ";"; :} 
;

expr ::= expr:e1 PLUS expr:e2   {: RESULT = e1 + " + " + e2 ; :}
        | IDENTIFIER:id         {: RESULT = id ; :}  
        | STRING_LITERAL:str    {: RESULT = "\"" + str + "\""; :}     
;

nested ::= if_else:ifel       {: RESULT = ifel; :}    
        | call:c              {: RESULT = c; :} 
;       

if_else ::= IF LPAREN condition:cond RPAREN block:bl1 ELSE block:bl2 {:RESULT = "if( " + cond +"){\n\t" + bl1 +"\n}\n" + bl2; :} 
;

condition ::= condition:c1 PREFIX condition:c2  {: RESULT = "( " + c2 + " )." + "startsWith"  + "( " + c1 + " )"; :}                  
    | REVERSE condition:c                       {: RESULT =  "( " + c + " ).reverse() "; :}  
    | STRING_LITERAL:str                        {: RESULT = "\"" + str + "\""; :}
;






