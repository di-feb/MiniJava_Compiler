import java_cup.runtime.*;

//  Usercode Components
parser code {:
    // Connect this parser to a scanner!
    Lexer s;
    Parser(Lexer s){ this.s=s; }
:}

// Define how to connect to the lexer!
scan with {: return s.next_token(); :};


// Symbol Lists
// Terminals (tokens returned by the scanner).
// Lexical Analysis is the process of converting a stream
// of characters into a sequence of tokens.
// A token represents a string with an assigned meaning
// that describes a series of related lexemes.
// A lexeme is a contiguous sequence of characters
// that form a lexical unit in the grammar of a language.

terminal            PLUS, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, IF, ELSE, PREFIX, REVERSE;
terminal String     STRING_LITERAL, IDENTIFIER;        // our scanner provides numbers as strings

// Non terminals
non terminal        program, definition_list, definition, call_list, parameters_list, parameters, block, expr, if_else, call, condition, nested ;

// Precedence Declarations
// In contrast to JFlex, precedence in CUP works bottom to up.
// That is, the earlier the declaration, the lower the precedence.
precedence left PLUS;
precedence left PREFIX;
precedence left REVERSE;


// // The Grammar Rules
start with program;
// The programms are concluded from function definitions and calls. 
// At the output we see the calls first and then the definitions.
program ::= definition_list:def_ls call_list:cls {: System.out.println("public class Main{\n\tpublic static void main(String[] args){\n" + cls + "\t}\n" + def_ls + "\n}"); :}
;
// definition_list
definition_list ::= definition_list:def_ls definition:def {: System.out.println("public static String " + def_ls + def); :}
                | //empty
;
// definition
definition ::= call:c LBRACKET block:bl RBRACKET 
;
// parameters_list
// parameters are comma separated identifiers.
parameters_list ::= parameters_list:prm_list parameters:prm
                |  
;   
// parameters
parameters ::= IDENTIFIER COMMA
            | IDENTIFIER 
            | STRING_LITERAL COMMA
            | STRING_LITERAL      
;

// Code block could be:
// just a string
// the arguments concatenated with + 
// call of a function
// a series of if statements.
block ::= expr:ex
        | nested
;

expr ::= expr:e1 PLUS expr:e2 
        | IDENTIFIER
        | STRING_LITERAL
;

nested ::= if_else
        | call
;

if_else ::= IF LPAREN condition:cond RPAREN block:bl1 ELSE block:bl2 
;

condition ::= condition PREFIX condition
    | condition REVERSE
    | REVERSE condition 
    | STRING_LITERAL
;

call_list ::= call:c call_list:cl  
            | 
;

call ::= IDENTIFIER LPAREN parameters_list:p RPAREN
;





